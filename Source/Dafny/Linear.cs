using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.Boogie;
using System.Diagnostics.Contracts;
using System.ComponentModel;

namespace Microsoft.Dafny.Linear {

  // TODO(andrea) move/remove
  static class Util {
    static public void PrintObject(Object obj) {
        System.Type t = obj.GetType();
        foreach(var fieldInfo in t.GetFields()) {
            Console.WriteLine("[f] {0}={1}", fieldInfo.Name, fieldInfo.GetValue(obj));
        }
        foreach(PropertyDescriptor descriptor in TypeDescriptor.GetProperties(obj))
        {
            string name=descriptor.Name;
            object value;
            try {
                value = descriptor.GetValue(obj);
            } catch (System.Reflection.TargetInvocationException e) {
                if (e.InnerException is NullReferenceException) {
                  value = "<NullReferenceException>";
                } else {
                  value = "<?Exception?>";
                }
            }
            Console.WriteLine("[p] {0}={1}",name,value);
        }
    }

    static public void PrintObjects(Object obj1, Object obj2) {
        System.Type t = obj1.GetType();
        foreach(var fieldInfo in t.GetFields()) {
            var value1 = fieldInfo.GetValue(obj1);
            var value2 = fieldInfo.GetValue(obj2);
            Console.WriteLine("[f] {3} {0} = {1} <> {2}", fieldInfo.Name,
                value1, value2, value1 != null ? (value1.Equals(value2) ? "  " : "!=") : "??");
        }
        foreach(PropertyDescriptor descriptor in TypeDescriptor.GetProperties(obj1))
        {
            string name=descriptor.Name;
            object value1;
            try {
                value1 = descriptor.GetValue(obj1);
            } catch (System.Reflection.TargetInvocationException e) {
                if (e.InnerException is NullReferenceException) {
                  value1 = "<NullReferenceException>";
                } else {
                  value1 = "<?Exception?>";
                }
            }
            object value2;
            try {
                value2 = descriptor.GetValue(obj2);
            } catch (System.Reflection.TargetInvocationException e) {
                if (e.InnerException is NullReferenceException) {
                  value2 = "<NullReferenceException>";
                } else {
                  value2 = "<?Exception?>";
                }
            }
            Console.WriteLine("[p] {3} {0} = {1} <> {2}", name, value1, value2, value1.Equals(value2) ? "  " : "!=");
        }
    }
  }

  class InoutVisitor : TopDownVisitor<Object> {
    protected override bool VisitOneExpr(Expression expr, ref Object context) {
      return true;
    }
  }

  public class InoutTranslateRewriter : IRewriter {
    public delegate string FreshTempVarName(string prefix, ICodeContext context);

    FreshTempVarName freshTempVarName;
    
    public InoutTranslateRewriter(ErrorReporter reporter, FreshTempVarName freshTempVarName) : base(reporter) {
      this.freshTempVarName = freshTempVarName;
    }

    Cloner cloner = new Cloner();

    (String, Expression)? DatatypeUpdateExprFor(Expression expr, Expression value) {
      var tok = new AutoGeneratedToken(expr.tok);
      if (expr is ExprDotName) {
        var dotName = (ExprDotName) expr;
        var newValue = new DatatypeUpdateExpr(tok, cloner.CloneExpr(dotName.Lhs),
          new List<Tuple<IToken, string, Expression>> { Tuple.Create((IToken) tok, dotName.SuffixName, value) });
        return DatatypeUpdateExprFor(dotName.Lhs, newValue);
      } else if (expr is NameSegment) {
        return (((NameSegment) expr).Name, value);
      } else {
        reporter.Error(MessageSource.Rewriter, expr.tok, "invalid inout argument");
        return null;
      }
    }

    void PreRewriteMethod(Method m) {
      Contract.Requires(m != null);
      // TODO(andrea) m.CompileOuts = m.Outs.ToList();
      // TODO(andrea) m.CompileIns = m.Ins.ToList();

      var body = m.Body?.Body;

      for (int i = 0; i < m.Ins.Count; i++) {
        if (m.Ins[i].Inout) {
          var f = m.Ins[i];
          m.Ins.RemoveAt(i);

          var fTok = new AutoGeneratedToken(f.tok);

          var outFormal = new Formal(fTok, f.Name, f.Type, false, f.Usage, false, false);
          m.Outs.Add(outFormal);

          var inFormal = new Formal(fTok, "old_" + f.Name, f.Type, false, f.Usage, false, true);
          m.Ins.Insert(i, inFormal);

          if (body != null) {
            var mTok = new AutoGeneratedToken(m.tok);

            var lhs = new IdentifierExpr(mTok, outFormal);
            var rhsNameSegment = new NameSegment(fTok, "old_" + f.Name, null);
            var rhs = new ExprRhs(rhsNameSegment);
            var updateStmt = new UpdateStmt(mTok, mTok,
              new List<Expression> { lhs },
              new List<AssignmentRhs> { rhs });
            updateStmt.InoutGenerated = false;
            m.Body.Body.Insert(0, updateStmt);
          }
        }
      }

      if (body != null) {
        for (int s = 0; s < m.Body.Body.Count; s++) {
          var stmt = body[s];
          var varDeclStmt = stmt as VarDeclStmt;
          var updStmt = (stmt as UpdateStmt) ?? (varDeclStmt?.Update as UpdateStmt);
          var applySuffix = (updStmt?.Rhss.First() as ExprRhs)?.Expr as ApplySuffix;
          if (applySuffix != null) {
            var inoutArgs = applySuffix.Args.Where(a => a.Inout).ToList();
            if (inoutArgs.Count == 0) {
              continue;
            }
            var updatedFields = inoutArgs.ConvertAll(a => {
              var aTok = new AutoGeneratedToken(a.Expr.tok);
              var varName = freshTempVarName("_inout_tmp_", m);
              var datatypeUpdateFor = DatatypeUpdateExprFor(a.Expr, new IdentifierExpr(aTok, varName));
              // TODO(andrea)
              UpdateStmt updateStmt = null;
              if (datatypeUpdateFor.HasValue) {
                var (updateName, updateExpr) = datatypeUpdateFor.Value;
                updateStmt = new UpdateStmt(aTok, aTok,
                  new List<Expression> { new IdentifierExpr(aTok, updateName) },
                  new List<AssignmentRhs> { new ExprRhs(updateExpr) });
                updateStmt.InoutGenerated = true;
                Console.WriteLine("OXIDE DEBUG varName: " + varName + ", " + Printer.ExprToString(a.Expr) + ", " + Printer.ExprToString(updateExpr));
              }
              return (
                new LocalVariable(aTok, aTok, varName, new InferredTypeProxy(), Usage.Ignore),
                updateStmt);
            });
            var tempLocalVars = updatedFields.Select(x => x.Item1).ToList();
            foreach (var tv in tempLocalVars) {
              updStmt.Lhss.Add(new IdentifierExpr(tv.Tok, tv.Name));
            }
            if (varDeclStmt == null) {
              var asTok = new AutoGeneratedToken(applySuffix.tok);
              varDeclStmt = new VarDeclStmt(asTok, asTok, tempLocalVars, null);
              body.Insert(s, varDeclStmt);
              // TODO(andrea)
              Console.WriteLine("OXIDE DEBUG " + Printer.StatementToString(body[s]));
              s++;
            } else {
              varDeclStmt.Locals.AddRange(tempLocalVars);
            }
            foreach (var newUpdStmt in updatedFields.Select(x => x.Item2)) {
              if (newUpdStmt != null) {
                s++;
                body.Insert(s, newUpdStmt);
              }
            }
            // TODO(andrea)
            Console.WriteLine("OXIDE DEBUG " + Printer.StatementToString(body[s]));
          }
        }
      }

    }

    static bool memberIsMethod(MemberDecl decl) {
      var m = decl as Method;
      if (m == null) {
        return false;
      }
      return !(
          m is Constructor ||
          m is InductiveLemma ||
          m is CoLemma ||
          m is Lemma ||
          m is TwoStateLemma);
    }

    static IEnumerable<Method> AllMethodMembers(ModuleDefinition module) {
      foreach (var decl in module.TopLevelDecls) {
        var cl = decl as ClassDecl;
        if (cl != null) {
          foreach (var m in cl.Members.Where(memberIsMethod)) {
            var method = (Method) m;
            yield return method;
          }
        }
      }
    }

    internal override void PreResolve(ModuleDefinition module) {
      foreach (Method method in AllMethodMembers(module)) {
        PreRewriteMethod(method);
      }
    }

  }
}
