    linear datatype Foo = Foo(x: int)

    function Set5(foo: Foo) : Foo {
      foo.(x := 5)
    }

This should be okay, because x is a base type and hence sharable

    function Inc5(foo: Foo) : Foo {
      foo.(x := foo.x + 5)
    }


Desugar: foo.(x := foo.x + 5)
Into:   
         take tmp_foo {x = tmp_x}  = foo in
         put tmp_foo.x := tmp_x + 5

Though maybe this isn't needed because x isn't linear?
Better example:


    linear datatype Bar = Bar(s:linear seq<int>, t:linear seq<int>)

    function NewSeq(b:Bar, m:seq<int>) : Bar {
      b.(s := m)
    }

    Should be disallowed because we drop b.s

    function NewSeq(b:Bar, m:seq<int>) : Bar {
      free(b.s);
      b.(s := m)
    }

    Should be okay

    function NewSeq(b:Bar) : Bar {
      free(b.s);
      b.(s := b.t)
    }

    Should be okay because it becomes:

         take tmp_b {t = tmp_t}  = b in
         put tmp_b.s := tmp_t

    and the result is a tmp_b where the t field is inaccessible

For sequences, maybe we can use the same take/put approach and rely on 
extra proof obligations to handle aliasing:

    function Add1ToElement5(s: linear seq <linear Foo>)
      requires |s| > 5
    {
      s[5].x := s[5].x + 1
    }

desugars to:

         take tmp_s {s[5] = foo} = s in       // Where this makes 5 inaccessible in tmp_s
         take tmp_foo {x = tmp_x} = foo in
         put tmp_foo.x := tmp_x + 5
         put tmp_s[5] := tmp_foo

How do we track accessiblility?  For any given variable, it's a static property,
since additional take operations will produce new values.  But a sequence might
have more than one index inaccessible, since you could do several takes in a row.
So we maintain a set (variable or function return value?) for each value that
returns all (in)accessible locations, and each index operation proves
that the attempted index is (not)in the (in)accessible set?  Doing a put
operation on a sequence would have a similar requirement.


