I want to be able to write our stateful computations
in a functional manner, since it's easier to work
with expressions for verification. We'd then want
the expressions compiled to actual, performant stateful code.

To illustrate, a common pattern we use is to define a function
and then a method which implements the function.

    datatype Foo = Foo(x: int)

    function Set5(foo: Foo) : Foo {
      foo.(x := 5)
    }

    class FooImpl {
      x: int;

      Repr: set<object>;

      function I() : Foo {
        Foo(this.x)
      }
    }

    method Set5Impl(foo: FooImpl)
    modifies foo.Repr
    ensures fresh(foo.Repr - old(foo.Repr))
    ensures foo.I() == Set5(old(foo.I()))
    {
      foo.x := 5;
    }

We'd like to automatically generate the `FooImpl` class and
`Set5Impl` method from `Foo` and `Set5`.

For this to be possible, a function like `Set5` needs to use
its arguments linearly - or at least, those arguments which
are going to replaced by a stateful class implementation.

    datatype Foo = Foo(x: int)

    function Invalid(foo: Foo) : (Foo, Foo) {
      (foo.(x := 5), foo.(x := 6))
    }

This obviously wouldn't be translatable into a method
implementation without somehow cloning `foo`.
(Cloning would need to be made explicit.)

=== More examples ===

We want an expression that will compile as:

    method Add1ToElement5(s: array<FooImpl>)
    {
      s[5].x := s[5].x + 1
    }

We could try (`!` denotes a linear type):

    function Add1ToElement5(s: !seq<!Foo>)
    requires |s| >= 6
    {
      // We want to write
      //   s[5 := s[5].(x := s[5].x + 1)]
      // but that's not linear.
      // (our dafny code frequently uses idioms like this).

      // Instead we could write something like:

      s.update(5, lambda foo: !Foo .
          foo.update_x(lambda y: int . y + 1))

      // This is a little annoying because Dafny's support
      // for higher order functions is not great.
    }

In general it's actually kind of annoying to only be able
to use something linearly and it would be good to have
mechanisms that allow for borrowing a linear type into a
non-linear type which would only be used immutably, a la
Rust's borrowing semantics. Wadler's paper also has some limited
support for this, I think.

=== Mutation vs returning new ===

Returning to the Set5 example, there are actually two ways
to translate this:

    function Set5(foo: !Foo) : !Foo {
      foo.(x := 5)
    }

    method Set5Impl1(foo: FooImpl)
    modifies foo.Repr
    ensures fresh(foo.Repr - old(foo.Repr))
    ensures foo.I() == Set5(old(foo.I()))
    {
      foo.x := 5;
    }

    method Set5Impl2(foo: FooImpl) returns (foo': FooImpl)
    modifies foo.Repr
    ensures fresh(foo'.Repr - old(foo.Repr))
    ensures foo'.I() == Set5(old(foo.I()))
    {
      var foo' := foo;
      foo.x := 5;
    }

Of course, some functions would only work with the second style:

    function Set5'(foo: !Foo) : !Foo {
      Foo(5) // datatype constructor
    }

    method Set5'Impl2(foo: FooImpl) returns (foo': FooImpl)
    modifies foo.Repr
    ensures fresh(foo'.Repr - old(foo.Repr))
    ensures foo'.I() == Set5(old(foo.I()))
    {
      foo' := new Foo(5); // constructor is translated to `new`
    }

We need some kind of syntax to specify which style any particular
argument is.

=== Sequences ===

Sequences are kind of tricky to use right. We'd need some special
constructs. Consider some code we might want to write:

Suppose we're given a function/method with this signature:

    function Transform(bucket: !Bucket) : (bucket': !Bucket)

    method TransformImpl(bucket: BucketImpl) returns (bucket': BucketImpl)
    modifies bucket.Repr
    ensures bucket'.I() == Transform(old(bucket))

We want to write code which translates into this:

    method ModifySeqImpl(s: seq<BucketImpl>, i: int)
    returns (s': seq<BucketImpl>)
    modifies SequenceRepr(s)
    ensures ISeq(s') == modifySeq(old(ISeq(s)))
    {
      var left := s[0..i];
      var mid := s[i];
      var mid' := TransformImpl(mid);
      s' := left + [mid'];
    }

It's not obvious how to do this since s is used more than once,
even though no particular element is used more than once.

We need some kind of sequence destructuring construct:

    function ModifySeq(s: !seq<!Bucket>, i: int)
    {
      var left, mid := splice(s, [0..i], [i]);
      var mid' := Transform(mid);
      left + [mid']
    }

The `splice` call would have preconditions that the provided ranges
don't intersect.

Some open questions: when does a sequence translate to a sequence
vs an array? Any reason to not always be an array?

=== Immutatable datatypes ===

The motivation is to auto-translate linear types into mutable class
types. Why stop there? We could auto-translate immutable types
into immutable types. What's the point? Maybe we have an immutable map
implementation, but for the verification reasoning, it's easier to
just think of it as an ordinary Dafny map for dafny proofs, without
having to write interpretation function calls everywhere.

(TODO is there a good example of where we'd use this in Veribetrfs
codebase?)

=== Garbage collection ===

In a linear type system, every linear value has to be
used exactly once.  In an affine type system, every
affine value must be used *at most* once.

We could either have a linear type system, with explicit
`free` statements to free up memory for objects we don't need anymore,
or use an affine type system with the free statements inserted
automatically.

Compare to C++'s std::unique_ptr. This is used affinely and
the destructor is implicity called via RAII when the std::unique_ptr
goes out of scope.

NOTE: While this helps somewhat with refcounting, it
doesn't help with refcounting for immutable objects which are shared
freely.

=== Control-flow ===

If the point is to implement everything functionally, how do we
implement, e.g., while-loops, which only exist in imperative dafny
code?

What I tend to do right now is just implement everything
recursively, but if this is done right (e.g., with tail calls)
then it can easily be transformed into a CFG. Dafny already does
this for single methods, at the very least.

=== Non-linear implementations encapsulated as types ===

Sometimes we might want to implement the mutable version of a
custom linear type with our own custom implementation that is proven
correct using dafny's usual set-based dynamic frames.
Such a class would need to adhere to the Repr idioms.

See the example in this directory, where an LRU queue is implemented
with a doubly-linked list and abstracted as a simple sequence.
