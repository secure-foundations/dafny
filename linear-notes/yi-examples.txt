module eexample {

datatype table = table(legs: int)

/*
    in the examples, we assume arguments are all linear
    t is being used linearly in this example
*/

function method set_leg(t: table) : table
{
	t.(legs := 4)
}

/*
    maybe we allow the datatype update syntax to be linear as well
    despite t being mentioned twice here?
    but we need to make sure that the destination of the update must match the source of the update?
*/

function method add_leg(t: table) : table
{
	t.(legs := t.legs + 1)
}

/*
    in the above case we have a linear function that borrows and returns the same t
    we want to extract the above as in-place-update, but should we return the pointer?
    we can do this:
    
    void add_leg(shared_ptr<table> t) {
        t->legs = t->legs + 1;
    }

    it can also be extracted as:

    shared_ptr<table> add_leg(shared_ptr<table> t) {
        t->legs = t->legs + 1;
        return t;
    }

    we can even extract add_leg as:

    shared_ptr<table> add_leg(shared_ptr<table> t) {
        shared_ptr<table> t_ = make_shared<table>(*t); // use the copy constructor
        t_->legs = t_->legs + 1;
        return t_;
    }

    but then this would just make a copy, and does not take advantage of the linearlity
*/

function method add_leg_copy(t: table) : table
{
	table(t.legs + 1)
}

/*
    in this case we have a linear function that borrows t, but does not return t.
    instead, we get a "new" table back, so we want to extract it as:

    shared_ptr<table> add_leg_copy(shared_ptr<table> t) {
        return make_shared<table>(t_->legs + 1); // use the table constructor
    }
*/

/*
    now maybe look at single level "nested" example, and how the extraction will workout
*/

datatype room = room(big_table: table, small_table: table)

function method add_leg_big_table(r: room) : room
{
    r.(big_table := add_leg(r.big_table))
}

/*
    using the second style, shold we be ignoring the return value from a linear function 
    since it borrows and returns the same thing? 

    shared_ptr<room> add_leg_big_table(shared_ptr<room> r) {
        shared_ptr<table> t_ = add_leg(r->big_table); 
        // t_ is just unused here?
        return r;
    }
*/

function method add_leg_big_table_bad(r: room) : room
{
    r.(big_table := add_leg(r.small_table))
}

/*
    seems to me the above case should not be allowed
    the destination of the update does not match the source of the update
    we cannot extract this as an in place update for either tables
*/

function method add_leg_big_table_copy(r: room) : room
{
    r.(big_table := add_leg_copy(r.big_table))
}

/*
    now in above case, we do want to reassign big_table:

    shared_ptr<room> add_leg_big_table(shared_ptr<room> r) {
        shared_ptr<table> t = add_leg_copy(r->big_table);
        r->big_table = t;
        return r;
    }
    
    so it seems like despite add_leg_copy and add_leg have the same signature
    the extraction on the caller side might need to change
    so the information needs to be carried somewhere
*/

/*
    now maybe look at a sequence example, seems like it gets tricker
*/

function method add_leg_first_table_okay(ts: seq<table>) : seq<table>
	requires |ts| > 1;
{
	ts[0 := add_leg(ts[0])]
}

/*
    we also want to extract the above as in-place-update
    
    shared_ptr<vector<shared_ptr<table>>> add_leg_first_table(shared_ptr<vector<shared_ptr<table>>> ts) {
        shared_ptr<table> t = add_leg(ts[0]); 
        return ts;
    }

    for the extraction to work, we have to disallow different indicies being passed in.
    the following cannot be compiled as an in place update
    again, the destination of the update does not match the source of the update
    maybe we just use a separate syntactic construct for in-place, linear update?
*/

function method add_leg_first_table_bad(ts: seq<table>) : seq<table>
	requires |ts| > 1;
{
	ts[1 := add_leg(ts[0])]
}

/*
    conceptually, this one should be okay, since a new copy is returned
*/

function method add_leg_first_table_maybe_okay(ts: seq<table>) : seq<table>
	requires |ts| > 1;
{
	ts[1 := add_leg_copy(ts[0])]
}

/*
    seems like we should be able to extract it this way:

    shared_ptr<vector<shared_ptr<table>>> add_leg_first_table_maybe_okay(shared_ptr<vector<shared_ptr<table>>> ts) {
       <shared_ptr<table> temp = add_leg_copy(ts[0]); // will envoke the constructor
       ts[1] = temp;
       return ts;
    }

    a slightly more complicated example:
*/

function method keep_some_tables(ts: seq<table>) : seq<table>
	requires |ts| > 5;
{
    var ts_0 := add_leg_first_table_okay(ts);
    var ts_1 := add_leg_first_table_okay(ts_0);
    ts_1[0..3]
}

/*
    ideally we would like to do:

    shared_ptr<vector<shared_ptr<table>>> keep_some_tables(shared_ptr<vector<shared_ptr<table>>> ts)
    {
        add_leg_first_table_okay(ts); 
        add_leg_first_table_okay(ts); 
        ts.resize(3); 
        return ts;
    }`
*/

}